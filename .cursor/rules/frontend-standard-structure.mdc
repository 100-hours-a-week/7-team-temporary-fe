---
alwaysApply: true
---
# Frontend Standard Structure Rules

이 문서는 `docs/frontend-standard-structure`의 핵심 규칙을 커서 룰로 요약한 것이다.

## 아키텍처/레이어(FSD)
- 레이어 순서: `shared → entities → features → widgets → pages`.
- 하위 레이어는 상위 레이어를 참조하지 않는다(역참조 금지).
- slice 외부 접근은 해당 slice의 `index.ts`(public API)로만 한다.
- `app` 레이어는 모든 레이어를 조합하는 진입점이며, 다른 레이어는 `app`을 참조하지 않는다.

## Next.js App Router
- 라우팅 엔트리는 `app/`에만 둔다. `app/**/page.tsx`는 라우팅 어댑터만 담당한다.
- `app/**/page.tsx`에서 허용되는 책임:
  - `params`/`searchParams` 파싱
  - 접근 제어 컴포넌트 wrapping
  - `src/pages/**`의 Page 컴포넌트 위임
- 실제 화면 조합/비즈니스 로직은 `src/pages/**`에 둔다.
- 접근 레벨은 `app/(public)`과 `app/(protected)`로 표현한다.
- `layout`은 공통 UI shell과 2차 보호 역할만 수행하고, 페이지 비즈니스 로직을 포함하지 않는다.

## 접근 제어/인증
- 인증 상태의 SSOT는 `AuthStore`.
- 접근 제어는 `middleware`(요청 단계)와 `AuthGuard`(UI 단계)로 분리한다.
- `middleware`는 `refreshToken` 쿠키 존재 여부만 판단하며 토큰 재발급/데이터 로딩을 하지 않는다.
- 401 처리는 `AuthService`가 해석하고, 상태 변경은 `AuthStore`가 담당한다.

## Route Handler / API 연동
- Route Handler는 인증 토큰 중계/접근 제어 용도로만 사용한다.
- `app/api`는 프록시/라우팅 용도로만 유지하며 비즈니스 로직을 넣지 않는다.
- Route Handler에서는 헤더/쿠키 전달과 status code 전달만 허용한다.
- 응답 데이터 shape 변환/가공은 금지한다.
- 네트워크 요청은 `apiFetch` 단일 진입점으로 통일한다.
- endpoint 정의는 `shared/api/endpoints`에서 관리한다.

## 상태 관리
- 서버 상태는 TanStack Query만 사용하고 `useApiQuery/useApiMutation`으로만 접근한다.
- queryKey는 `queryKeyFactory`로 생성한다.
- mutation 후 전역 invalidate 금지, 관련 query만 명시적으로 invalidate 한다.
- 캐시는 직접 수정하지 않고 invalidate → refetch로 동기화한다.
- 전역 UI 상태는 Zustand로 제한하고, 도메인 데이터의 SSOT는 서버로 유지한다.

## 폼/모델/DTO
- Form Component는 입력/검증, Form Model 생성만 담당한다.
- Form Model/Request DTO 타입은 `features/*/model/types.ts`에 둔다.
- DTO 변환은 mutation의 `dtoFn`에서 수행한다.
- 서버 응답은 entities 모델(schema)로 검증 후 ViewModel로 매핑한다.

## 공통 UI/디자인 시스템
- 공통 UI는 `shared/ui`, shadcn wrapper는 `shared/ui/shadcn`, 토큰은 `shared/styles`에 둔다.
- 공통 UI는 비즈니스 로직/도메인 판단을 포함하지 않는다.
- `isOwner`, `canEdit` 같은 도메인 의미 props를 공통 UI에 추가하지 않는다.
- 도메인 규칙이 섞이면 feature/widget로 이동한다.
- Emotion은 정책 기반 UI에만 사용하며 `shared/ui`에서는 금지한다.
- 정책 기반 UI란:
  - 시간/상태/권한에 따라 스타일 규칙이 변하는 UI
  - Tailwind 조건 분기로 표현이 어려운 경우

## 반응형/모션
- 모바일 퍼스트 + 반응형 레이아웃을 따른다.
- 고정 픽셀 값 지양, 상대 단위를 사용한다.
- 모션은 목적에 따라 `react-bits`/`GSAP`를 사용한다.
  - 단순 인터랙션/마이크로 모션: `react-bits`
  - 타임라인/스크롤 연동/복합 시퀀스: `GSAP`
- `transform`, `opacity` 기반 애니메이션을 사용하고 `height/width/top/left` 애니메이션은 금지한다.
- `prefers-reduced-motion`을 존중하며, 모션 훅은 `"use client"`에서만 사용한다.

## 코드 컨벤션
- 변수/함수/컴포넌트/props/interface는 의미가 명확한 이름을 사용한다.
- boolean은 `is/has/can/should` 접두어를 사용한다.
- 도메인 용어는 문서의 용어 기준을 따른다.
- 축약어는 팀 내 합의된 경우에만 사용한다.
- `any` 사용 금지, 명시적 타입을 우선한다.
- 서버 응답 타입과 화면 모델 타입을 분리한다.
- 타입 단언(`as`)은 불가피한 경우에만 사용한다.
- 비즈니스 로직과 UI 로직을 분리하고, 컴포넌트는 단일 책임 원칙을 따른다.
- 순수 함수 원칙은 계산/판단 로직 및 util 함수에 적용한다.
- hook, effect, mutation은 본질적으로 side effect를 포함할 수 있다.
- 절대 경로 import 사용, 레이어 역참조 금지, 순환 의존성 금지.

## Lint / Formatting
- ESLint는 논리/구조/안전성 규칙을 담당하고, 스타일은 Prettier에 위임한다.
- import 순서는 `builtin → external → internal → parent → sibling → index → type`를 따른다.
- import 그룹 간 빈 줄, 동일 그룹 내 알파벳 정렬을 유지한다.
- 레이어 의존성 규칙은 ESLint(boundaries)와 Dependency Cruiser로 검증한다.

## 브라우저/호환성/PWA
- 최신 Chromium/Firefox/Safari만 지원하며 IE는 지원하지 않는다.
- 레거시 브라우저를 위한 전역 polyfill은 기본적으로 적용하지 않는다.
- Service Worker는 UI(App Shell) 캐싱과 푸시 알림에만 책임을 둔다.
- API 응답은 SW 캐시 대상에서 제외하고 최신성은 TanStack Query로 보장한다.

## Polyfill
- 필요 시 selective polyfill만 적용하고 core-js 전체 적용은 지양한다.
- 전역 polyfill은 `app/polyfills.ts`를 `app/layout.tsx`에서 import한다.
- 특정 기능 polyfill은 feature 내부에서 조건부/dynamic import로 적용한다.
- 서버 컴포넌트/도메인 로직 계층에는 polyfill을 두지 않는다.

## SEO/메타데이터
- SEO 대상은 공개 페이지이며, 메타데이터는 서버 컴포넌트에서 정의한다.
- CSR 페이지는 SEO 대상에서 제외한다.

## 테스트/운영
- 단위/통합 테스트를 우선하고, E2E는 핵심 플로우에 한정한다.
- UI 스냅샷 테스트는 최소화한다.
- 에러 처리 기준은 HTTP `status`로 분기하며 `401`은 `AuthService`가 처리한다.
- 실시간 데이터는 WebSocket/SSE/WebRTC/Polling로 처리하고 Query는 캐시 조회에 한정한다.
- Storybook을 UI 문서로 사용하고 `*.stories.tsx`를 컴포넌트와 동일 폴더에 둔다.
