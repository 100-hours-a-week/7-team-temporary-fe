## 12. 지원 브라우저 범위 및 호환성

### 12.1 지원 대상

- 최신 Chromium 계열 (Chrome, Edge 등)
- Safari 최신 버전 (macOS, iOS)
- Firefox 최신 버전
- 각 브라우저는 공식 지원 중인 최신 메이저 버전을 기준으로 지원한다.
- JavaScript는 ES2023 이상, CSS는 최신 표준 스펙을 전제로 개발한다.

### 12.2 비지원 범위

- Internet Explorer(IE)는 지원하지 않는다.
- 공식 지원 종료 또는 최신 표준 미지원 환경은 정상 동작을 보장하지 않는다.
- 비지원 환경에서 발생하는 UI 깨짐/기능 미동작은 별도 대응하지 않는다.

### 12.3 호환성 정책

- 레거시 브라우저 대응 Polyfill은 적용하지 않는다.
- 표준 API 사용으로 차이를 최소화하고 필요 시 런타임 분기 또는 Graceful Degradation을 적용한다.
- 호환성 검증은 최신 브라우저 기준으로 수행한다.

### 12.4 PWA 지원 전략

#### 12.4.1 역할 및 목적

- 오프라인/저속 네트워크 환경에서 핵심 기능의 최소 동작을 보장한다.
- 정적 자산 캐싱으로 초기 로딩 성능을 개선한다.
- PWA 설치/푸시 알림을 위한 기반을 제공한다.

#### 12.4.2 Service Worker 역할 및 책임

- 네트워크 요청과 캐시 정책을 제어한다.
- 오프라인 진입 시 UI(App Shell)와 대체 응답을 제공한다.
- 푸시 알림/백그라운드 동기화 기반을 제공한다.
- 책임 범위는 UI(App Shell) 캐싱과 푸시 알림 처리로 제한한다.
- 서버 데이터(API 응답), 비즈니스 로직, 상태 관리는 책임 범위에서 제외한다.
- 서버 데이터 캐싱 및 동기화는 TanStack Query가 전담한다.

#### 12.4.3 적용 위치 및 등록 기준

- Service Worker는 `public/sw.js` 또는 빌드 산출물로 관리한다.
- 등록은 클라이언트 전용 영역에서만 수행한다.
  - 예: `app/layout.tsx`의 client wrapper 또는 `shared/lib/pwa/register.ts`
- 개발 환경에서는 자동 등록을 비활성화한다.

#### 12.4.4 캐싱 설계

##### 12.4.4.1 캐싱 대상 및 제외

Service Worker 캐싱은 리소스 타입 기준으로 적용한다.

- 캐싱 대상
  - HTML (`index.html`)
  - JavaScript 번들 (`/_next/static/**`)
  - CSS (`/_next/static/**`)
  - 폰트/아이콘 등 변경 가능성이 낮은 정적 리소스
- 캐싱 제외
  - API 요청 (`/api/**`)
  - 인증/세션 관련 요청
  - WebSocket(STOMP) 및 실시간 통신
  - 사용자별 개인화 데이터

##### 12.4.4.2 캐시 전략 기준

리소스 성격에 따라 캐시 전략을 분리 적용한다.

- [[ADR‐FE‐01]Service Worker 캐시 전략 설계 결정](https://github.com/100-hours-a-week/7-team-temporary-wiki/wiki/%5BADR%E2%80%90FE%E2%80%9001%5DService-Worker-%EC%BA%90%EC%8B%9C-%EC%A0%84%EB%9E%B5-%EC%84%A4%EA%B3%84-%EA%B2%B0%EC%A0%95)

혼합 전략 적용 배경

- 단일 캐시 전략(cache-first 또는 network-first)을 모든 리소스에 일괄 적용하면 한계가 발생할 수 있다.
  - UI(App Shell)는 항상 최신 버전 반영이 중요하다.
  - 일부 정적 리소스(폰트, 아이콘 등)는 변경 빈도가 매우 낮다.
  - 모든 리소스에 network-first를 적용하면 불필요한 네트워크 요청이 증가할 수 있다.
- 리소스 성격에 따라 캐시 전략을 분리 적용하는 혼합 전략을 사용한다.

| 리소스 유형               | 특성                           | 캐시 전략                                 |
| ------------------------- | ------------------------------ | ----------------------------------------- |
| App Shell (HTML, JS 번들) | 버전 변경 빈번, UI 최신성 중요 | network-first                             |
| API 응답                  | 데이터 최신성 중요             | network-first 또는 stale-while-revalidate |
| 이미지(아이콘)            | 변경 빈도 낮음                 | cache-first                               |
| 폰트                      | 거의 변경 없음                 | cache-first                               |
| 정적 에셋(로고 등)        | 장기 캐싱 가능                 | cache-first                               |

- UI(App Shell) 리소스
  - 전략: network-first
  - 온라인 환경에서는 네트워크 응답을 우선 사용한다.
  - 네트워크 실패 시 캐시된 리소스를 fallback으로 사용한다.
  - 오프라인 실행 보장을 위해 캐시를 유지한다.
- 변경 가능성이 거의 없는 정적 리소스
  - 전략: cache-first
  - 폰트/아이콘 등 최신성 요구가 낮은 리소스에 한해 적용한다.
- 서버 데이터(API)
  - Service Worker 캐시 대상에서 제외한다.
  - TanStack Query는 network-first를 기본으로 사용한다.
- 빈번히 변하는 데이터
  - 실시간성이 높은 데이터는 캐시 의존도를 최소화한다.
  - TanStack Query 기준 `staleTime = 0`을 적용한다.
- 인증/세션 관련 데이터
  - 인증/세션 엔드포인트는 캐시 대상에서 제외한다.

##### 12.4.4.3 캐시 무효화 정책

- 캐시 무효화는 단순한 버전 단위 전략을 따른다.
- 정책
  1. 새로운 Service Worker가 활성화되면
  2. 기존 Cache Storage를 모두 삭제하고
  3. 새 버전의 캐시만 유지한다.
- 부분 무효화나 리소스 단위 갱신은 수행하지 않는다.

##### 12.4.4.4 오프라인 동작 범위

- 오프라인 환경에서는 앱 UI 로딩(App Shell 표시)까지만 보장한다.
- 오프라인 상태에서 데이터 조회/생성/수정은 지원하지 않는다.
- 네트워크 연결이 필요한 기능은 명시적으로 실패 처리한다.

##### 12.4.4.5 설계 판단 요약

- 캐싱 복잡도를 최소화하기 위해 역할을 UI 캐싱으로 제한한다.
- 최신 UI 반영을 우선하기 위해 cache-first를 기본 전략으로 사용하지 않는다.
- 캐시 무효화 및 업데이트 정책은 예측 가능성과 디버깅 용이성을 우선한다.

#### 12.4.5 업데이트 정책

- 새 버전이 감지되면 사용자에게 업데이트 안내를 제공한다.
- UI 업데이트는 재접속 또는 새로고침 시 반영된다.
- 실행 중인 탭에 대해 강제 업데이트를 수행하지 않는다.
- `skipWaiting`, `clients.claim` 등 즉시 전환 기능은 기본적으로 사용하지 않으며,
  즉시 반영이 필요한 경우에만 제한적으로 사용한다.
- 캐시 무효화 기준을 문서화한다.

#### 12.4.6 운영/주의사항

- Service Worker는 디버깅이 어렵기 때문에 로그/버전 정책을 명시한다.
- 캐시 오염이 발생하면 클라이언트에서 강제 재등록/삭제 동선을 제공한다.
- Service Worker가 API 캐시에 개입하지 않도록 범위를 명확히 구분한다.
- 적용 시나리오(예시)
  - 조회 중심 화면 오프라인 가독성 유지: App Shell 제공 + TanStack Query 캐시로 기존 데이터 열람, 신규 요청은 오프라인 안내.
  - 반복 사용 SPA 체감 성능 개선: App Shell 즉시 로드 + 빠른 부트스트랩 + 데이터만 네트워크 동기화.

#### 12.4.7 푸시 알림 적용 범위

##### 12.4.7.1 적용 목적

- 앱이 백그라운드 또는 종료 상태일 때도 사용자에게 중요 이벤트를 전달한다.
- 실시간 데이터 동기화/ UI 업데이트가 아닌 사용자 인지를 위한 수단으로만 사용한다.

##### 12.4.7.2 Service Worker 역할

- Service Worker는 푸시 이벤트 수신 및 알림 표시만 담당한다.
- 알림 수신 시 UI 렌더링/상태 관리/데이터 갱신은 수행하지 않는다.

##### 12.4.7.3 푸시 알림 적용 대상

푸시 알림은 즉시 사용자 확인이 필요한 이벤트로 한정한다.

- 채팅 메시지 수신 알림
- 캠 스터디/그룹 채팅 신규 메시지
- 시스템성 알림(공지, 제한 도달 알림 등)

##### 12.4.7.4 적용 제외 대상

다음 항목은 푸시 알림으로 처리하지 않는다.

- 일반 데이터 변경 사항
- 플래너/메모 자동 갱신
- 서버 상태 동기화
- 실시간 UI 반영

해당 기능은 앱 실행 후 네트워크 요청(WebSocket(STOMP), API)으로 처리한다.

##### 12.4.7.5 알림 처리 방식

- 푸시 수신 시 Service Worker는 Notification API를 통해 알림만 표시한다.
- 알림 클릭 시 앱을 포그라운드로 전환하거나 지정된 라우트로 이동한다.
- 알림 클릭 이후의 데이터 동기화는 앱 실행 후 클라이언트 로직에서 처리한다.

##### 12.4.7.6 인증 및 보안 기준

- 푸시 알림 수신 여부는 로그인 상태 및 사용자 동의를 전제로 한다.
- Service Worker는 인증 상태를 판단하지 않으며 사용자 데이터에 직접 접근하지 않는다.
- 알림 payload에는 민감 정보 포함을 제한한다.

##### 12.4.7.7 오프라인 환경에서의 동작

- 네트워크 연결 상태에서 수신된 푸시 알림은 앱 실행 여부와 무관하게 표시될 수 있다.
- 알림 클릭 후 데이터 조회는 네트워크 연결이 가능한 경우에만 수행된다.

##### 12.4.7.8 설계 판단 요약

- 푸시 알림은 백그라운드 사용자 인지 수단으로만 사용한다.
- Service Worker의 책임은 알림 수신 및 표시로 제한한다.
- 데이터 처리 및 상태 반영은 앱 포그라운드 진입 이후로 위임한다.

##### 12.4.7.9 전체 흐름

**서버**

- 특정 이벤트 발생(예: 채팅 메시지 수신)
- Web Push Protocol을 통해 푸시 메시지 전송

**브라우저**

- 해당 origin의 Service Worker 등록 여부 확인
- Service Worker를 깨워 push 이벤트 전달

**Service Worker**

- push 이벤트 수신
- payload 파싱
- Notification API 호출

```js
self.addEventListener("push", (event) => {
  const data = event.data?.json();

  self.registration.showNotification(data.title, {
    body: data.body,
    data: data.payload,
  });
});
```

**사용자**

- OS/브라우저 알림 영역에서 알림 확인
