## 4. 접근 제어 및 인증 흐름 설계

### 4.1 접근 제어 계층 분리 전략

- **단일 진실(SSOT):** 인증 상태의 단일 진실은 `AuthStore`이다.
- 접근 제어는 **요청 단계(미들웨어)** 와 **UI 단계(AuthGuard)** 로 분리한다.
- 서버 레벨: middleware에서 RT 쿠키 기반 1차 접근 제어
- SSR 단계: (protected)/layout에서 공통 보호 UI 적용
- CSR 단계: AuthGuard로 전환/깜빡임 보정

### 4.2 middleware 역할 정의

- 역할: 요청이 페이지/레이아웃 로직에 도달하기 전에 접근을 제어한다.
- 판단 기준: `refreshToken` 쿠키 존재 여부
- accessToken은 Authorization 헤더로만 전달하며, 미들웨어 판단에 사용하지 않는다.
- 미들웨어 동작
  - 보호 라우트에 `refreshToken` 없음 → `/login` 리다이렉트
  - 공개 라우트(`/login`, `/sign-up/*`)에 `refreshToken` 있음 → `/home` 리다이렉트
- 하지 않는 것: 토큰 재발급, API 호출, 유저 데이터 로딩

### 4.3 Client Guard(AuthGuard) 역할

- 역할: 미들웨어 이후 단계에서 UI 상태와 라우트를 동기화한다.
- 판단 기준: `AuthStore.isAuthenticated`
- 수행 흐름
  - 로그인 성공 → `AuthStore.setAuthenticated(accessToken)` → `/home` 이동
  - 로그아웃/refresh 실패 → `AuthStore.clearAuth()` → `/login` 이동
- 역할 구분
  - Middleware: 요청 단위 “접근” 제어
  - AuthGuard: “인증 상태 변화”에 따른 UI 흐름 보정

### 4.4 공개/보호 라우트 정책

- 공개 라우트 예시: `/login`, `/sign-up/*`, `/둘러보기`, `/회고`
- 공개 라우트 외는 모두 보호 대상
- 인증되지 않은 상태에서 접근 시 `/login` 리다이렉트

### 4.5 토큰 인증 실패 처리

- 인증 실패 해석은 `AuthService`가 담당한다.
- 일반 API 요청에서 401 발생 시 refresh token 재발급(`PUT /token`)을 시도한다.
- 복구 실패 시 인증 상태를 무효화하고 `/login`으로 이동한다.
- 오류 해석 함수 예시

```tsx
handleAuthError(error: ApiError): Promise<AuthResolution>
```

---
